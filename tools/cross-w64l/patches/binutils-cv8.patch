diff -pruN binutils-2.25.1.orig/bfd/bfd-in2.h binutils-2.25.1/bfd/bfd-in2.h
--- binutils-2.25.1.orig/bfd/bfd-in2.h	2016-01-14 13:00:17 -0500
+++ binutils-2.25.1/bfd/bfd-in2.h	2016-01-14 12:36:28 -0500
@@ -1571,6 +1571,8 @@ typedef struct bfd_section
 
   void *used_by_bfd;
 
+  void *debugS_outinfo;
+
   /* If this is a constructor section then here is a list of the
      relocations created to relocate items within it.  */
   struct relent_chain *constructor_chain;
@@ -1776,8 +1778,8 @@ extern asection _bfd_std_section[4];
   /* entsize, kept_section, moving_line_filepos,                    */ \
      0,       NULL,          0,                                        \
                                                                        \
-  /* target_index, used_by_bfd, constructor_chain, owner,          */  \
-     0,            NULL,        NULL,              NULL,               \
+  /* target_index, used_by_bfd, debugS_outinfo, constructor_chain, owner, */ \
+     0,            NULL,        NULL,           NULL,              NULL, \
                                                                        \
   /* symbol,                    symbol_ptr_ptr,                    */  \
      (struct bfd_symbol *) SYM, &SEC.symbol,                           \
diff -pruN binutils-2.25.1.orig/bfd/cofflink.c binutils-2.25.1/bfd/cofflink.c
--- binutils-2.25.1.orig/bfd/cofflink.c	2016-01-14 13:00:17 -0500
+++ binutils-2.25.1/bfd/cofflink.c	2016-01-14 13:04:58 -0500
@@ -28,6 +28,7 @@
 #include "coff/internal.h"
 #include "libcoff.h"
 #include "safe-ctype.h"
+#include "coff/pe_debugS.h"
 
 static bfd_boolean coff_link_add_object_symbols (bfd *, struct bfd_link_info *);
 static bfd_boolean coff_link_check_archive_element
@@ -856,6 +857,42 @@ _bfd_coff_final_link (bfd *abfd,
 		goto error_return;
 	    }
 	}
+      if (!strcmp(o->name, ".debug$S") && o->debugS_outinfo) {
+	struct debugS_outinfo *doi;
+	struct debugS_header dsh;
+	struct debugS_portion dsp;
+	unsigned int s;
+
+	doi = o->debugS_outinfo;
+
+	dsh.dsh_version = 4;
+	if (! bfd_set_section_contents (abfd, o, &dsh, 0, sizeof(dsh)))
+	  goto error_return;
+
+	dsp.dsp_type = 0xf4;
+	dsp.dsp_len = doi->doi_fis_dot;
+	s = offsetof(struct debugS_portion, dsp_data);
+	if (! bfd_set_section_contents (abfd, o, &dsp, doi->doi_dot, s))
+	  goto error_return;
+	doi->doi_dot += s;
+
+	if (! bfd_set_section_contents (abfd, o, doi->doi_fis, doi->doi_dot,
+					doi->doi_fis_dot))
+	  goto error_return;
+	doi->doi_dot += doi->doi_fis_dot;
+
+	dsp.dsp_type = 0xf3;
+	dsp.dsp_len = doi->doi_fns_dot;
+	s = offsetof(struct debugS_portion, dsp_data);
+	if (! bfd_set_section_contents (abfd, o, &dsp, doi->doi_dot, s))
+	  goto error_return;
+	doi->doi_dot += s;
+
+	if (! bfd_set_section_contents (abfd, o, doi->doi_fns, doi->doi_dot,
+					doi->doi_fns_dot))
+	  goto error_return;
+	doi->doi_dot += doi->doi_fns_dot;
+      }
     }
 
   if (flaginfo.info->strip != strip_all && flaginfo.info->discard != discard_all)
@@ -2316,6 +2353,7 @@ _bfd_coff_link_input_bfd (struct coff_fi
     {
       bfd_byte *contents;
       struct coff_section_tdata *secdata;
+      int written = 0;
 
       if (! o->linker_mark)
 	/* This section was omitted from the link.  */
@@ -2398,6 +2436,63 @@ _bfd_coff_link_input_bfd (struct coff_fi
 		   h->root.root.string, o, input_bfd, ps, ps->owner);
 	    }
 
+	  if (!strcmp(o->name, ".debug$S"))
+	    written = 1;
+	  if (!strcmp(o->name, ".debug$S") &&
+	      o->output_section->debugS_outinfo) {
+	    struct debugS_outinfo *doi;
+	    struct debugS_header *dsh;
+	    struct debugS_portion *dsp;
+	    struct internal_reloc *irelend;
+	    unsigned int dspoff;
+
+	    doi = o->output_section->debugS_outinfo;
+
+	    if ((o->flags & SEC_HAS_CONTENTS) == 0) {
+	      (*_bfd_error_handler)(_("%B: no contents loaded from debugS"),
+				    input_bfd, o);
+	      bfd_set_error (bfd_error_no_contents);
+	      return FALSE;
+	    }
+
+	    dsh = (struct debugS_header *)o->contents;
+	    dsp = (struct debugS_portion *)dsh->dsh_data;
+
+	    irel = internal_relocs;
+	    irelend = irel + o->reloc_count;
+
+	    while ((unsigned char *)dsp < o->contents + o->rawsize) {
+	      dspoff = (unsigned char *)dsp - o->contents;
+
+	      while (irel < irelend && irel->r_vaddr <
+		     (dspoff + sizeof(*dsp) + dsp->dsp_len)) {
+		if (irel->r_vaddr >= dspoff) {
+		  irel->r_vaddr = doi->doi_dot + (irel->r_vaddr - dspoff);
+		  if (dsp->dsp_type != 0xf2)
+		    printf("reloc of non-f2 portion %x\n", dsp->dsp_type);
+		}
+		irel->r_vaddr -= o->output_offset;
+		irel++;
+	      }
+
+	      switch (dsp->dsp_type) {
+	      case 0xf2:
+		debugS_printf("debugS 0xf2 portion from %s at 0x%x, "
+			      "len 0x%lx\n", o->owner->filename, doi->doi_dot,
+			      sizeof(*dsp) + dsp->dsp_len);
+
+		if (! bfd_set_section_contents (output_bfd, o->output_section,
+						dsp, doi->doi_dot,
+						sizeof(*dsp) + dsp->dsp_len))
+		  return FALSE;
+		doi->doi_dot += sizeof(*dsp) + dsp->dsp_len;
+
+		break;
+	      }
+	      dsp = (struct debugS_portion *)(dsp->dsp_data + dsp->dsp_len);
+	    }
+	  }
+
 	  /* Call processor specific code to relocate the section
              contents.  */
 	  if (! bfd_coff_relocate_section (output_bfd, flaginfo->info,
@@ -2494,9 +2589,13 @@ _bfd_coff_link_input_bfd (struct coff_fi
 
 	      o->output_section->reloc_count += o->reloc_count;
 	    }
-	}
+	} else if (!strcmp(o->name, ".debug$S"))
+          written = 1;
 
       /* Write out the modified section contents.  */
+      if (written)
+	written = 0;
+      else
       if (secdata == NULL || secdata->stab_info == NULL)
 	{
 	  file_ptr loc = o->output_offset * bfd_octets_per_byte (output_bfd);
diff -pruN binutils-2.25.1.orig/bfd/section.c binutils-2.25.1/bfd/section.c
--- binutils-2.25.1.orig/bfd/section.c	2016-01-14 13:00:17 -0500
+++ binutils-2.25.1/bfd/section.c	2016-01-14 12:36:28 -0500
@@ -508,6 +508,8 @@ CODE_FRAGMENT
 .
 .  void *used_by_bfd;
 .
+.  void *debugS_outinfo;
+.
 .  {* If this is a constructor section then here is a list of the
 .     relocations created to relocate items within it.  *}
 .  struct relent_chain *constructor_chain;
@@ -713,8 +715,8 @@ CODE_FRAGMENT
 .  {* entsize, kept_section, moving_line_filepos,		     *}	\
 .     0,       NULL,	      0,					\
 .									\
-.  {* target_index, used_by_bfd, constructor_chain, owner,          *}	\
-.     0,            NULL,        NULL,              NULL,		\
+.  {* target_index, used_by_bfd, debugS_outinfo, constructor_chain, owner, *} \
+.     0,            NULL,        NULL,           NULL,              NULL, \
 .									\
 .  {* symbol,                    symbol_ptr_ptr,                    *}	\
 .     (struct bfd_symbol *) SYM, &SEC.symbol,				\
diff -pruN binutils-2.25.1.orig/gas/dwarf2dbg.c binutils-2.25.1/gas/dwarf2dbg.c
--- binutils-2.25.1.orig/gas/dwarf2dbg.c	2016-01-14 13:00:17 -0500
+++ binutils-2.25.1/gas/dwarf2dbg.c	2016-01-14 12:36:28 -0500
@@ -1853,6 +1853,7 @@ dwarf2_finish (void)
   segT info_seg;
   int emit_other_sections = 0;
   int empty_debug_line = 0;
+  segT debugS_seg;
 
   info_seg = bfd_get_section_by_name (stdoutput, ".debug_info");
   emit_other_sections = info_seg == NULL || !seg_not_empty_p (info_seg);
@@ -1875,10 +1876,6 @@ dwarf2_finish (void)
   /* Calculate the size of an address for the target machine.  */
   sizeof_address = DWARF2_ADDR_SIZE (stdoutput);
 
-  /* Create and switch to the line number section.  */
-  line_seg = subseg_new (".debug_line", 0);
-  bfd_set_section_flags (stdoutput, line_seg, SEC_READONLY | SEC_DEBUGGING);
-
   /* For each subsection, chain the debug entries together.  */
   for (s = all_segs; s; s = s->next)
     {
@@ -1892,6 +1889,183 @@ dwarf2_finish (void)
 	}
     }
 
+  /* Create and switch to the debugS section.  */
+  debugS_seg = subseg_new (".debug$S", 0);
+  bfd_set_section_flags (stdoutput, debugS_seg, SEC_READONLY | SEC_DEBUGGING);
+  out_four(0x4);
+
+  {
+    unsigned int i;
+    // struct line_seg *s;
+    symbolS *lab;
+    fragS *frag, *lfrag = NULL;
+    addressT frag_ofs, lfrag_ofs = 0;
+    unsigned int filenum = files_in_use;
+    expressionS exp;
+    int sizeof_offset = 0;
+    symbolS *debugS_size = NULL;
+    symbolS *debugS_f2_size = NULL;
+    symbolS *debugS_f2_nrlines = NULL;
+    symbolS *debugS_f2_linebytes = NULL;
+    symbolS *debugS_f2_codelen = NULL;
+    symbolS *debugS_f2_start = NULL;
+    int nrlines = 0;
+    unsigned int linenum = INT_MAX;
+    int cur_offset;
+
+#if 0
+    for (i = 1; i < files_in_use; ++i)
+      printf("file %d: %s dir %d/%s\n", i, files[i].filename ? : "<undef>",
+	     files[i].dir, files[i].dir ? dirs[files[i].dir] : "<undex>");
+#endif
+    for (s = all_segs; s; s = s->next) {
+      /* process_entries (s->seg, s->head->head); */
+      struct line_entry *e = s->head->head;
+      do {
+	lab = e->label;
+	frag = symbol_get_frag (lab);
+	frag_ofs = S_GET_VALUE (lab);
+#if 0
+	printf("filenum %d line %d addr %lx\n", e->loc.filenum, e->loc.line,
+	       frag_ofs);
+#endif
+	if (filenum != e->loc.filenum) {
+	  if (debugS_f2_size) {
+	    symbol_set_value_now (debugS_f2_size);
+	    *symbol_X_add_number(debugS_f2_nrlines) = nrlines;
+	    *symbol_X_add_number(debugS_f2_linebytes) = 12 + nrlines * 8;
+	    /* XXX assume frag/frag_ofs now point to end of previous f2 */
+	    S_SET_VALUE(debugS_f2_codelen, frag_ofs);
+	    symbol_set_frag(debugS_f2_codelen, frag);
+	    nrlines = 0;
+	  }
+	  out_four(0xf2);
+	  sizeof_offset = out_header (debugS_seg, &exp); /* section size */
+	  debugS_f2_size = exp.X_add_symbol;
+
+	  /* TC_DWARF2_EMIT_OFFSET (lab, sizeof_offset); */
+	  exp.X_op = O_secrel;
+	  exp.X_add_symbol = lab;
+	  exp.X_add_number = 0x0;
+	  emit_expr (&exp, sizeof_offset);
+
+	  out_two(0x1);		/* XXX .text section index */
+	  out_two(0x0);		/* pad1 */
+
+	  lfrag = last_frag_for_seg(s->seg);
+	  lfrag_ofs = get_frag_fix(lfrag, s->seg);
+	  exp.X_op = O_subtract;
+	  exp.X_add_symbol = symbol_temp_new(s->seg, frag_ofs, frag);
+	  exp.X_op_symbol = symbol_temp_new(s->seg, frag_ofs, frag);
+	  exp.X_add_number = 0;
+	  emit_expr(&exp, sizeof_offset);
+	  debugS_f2_codelen = exp.X_add_symbol;
+
+	  out_four((e->loc.filenum - 1) * 8); /* offset of source file info */
+
+	  exp.X_op = O_subtract;
+	  exp.X_add_symbol = symbol_temp_new(s->seg, 0,
+					     first_frag_for_seg(s->seg));
+	  exp.X_op_symbol = symbol_temp_new(s->seg, 0,
+					    first_frag_for_seg(s->seg));
+	  exp.X_add_number = 0;
+	  emit_expr(&exp, sizeof_offset); /* place holder for nr lines */
+	  debugS_f2_nrlines = exp.X_add_symbol;
+
+	  exp.X_op = O_subtract;
+	  exp.X_add_symbol = symbol_temp_new(s->seg, 0,
+					     first_frag_for_seg(s->seg));
+	  exp.X_op_symbol = symbol_temp_new(s->seg, 0,
+					    first_frag_for_seg(s->seg));
+	  exp.X_add_number = 0;
+	  emit_expr(&exp, sizeof_offset); /* place holder for line bytes */
+	  debugS_f2_linebytes = exp.X_add_symbol;
+
+	  debugS_f2_start = symbol_temp_new(s->seg, frag_ofs, frag);
+
+	  filenum = e->loc.filenum;
+	  linenum = INT_MAX;
+	}
+	if (linenum != e->loc.line) {
+	  exp.X_op = O_subtract;
+	  exp.X_add_symbol = symbol_temp_new(s->seg, frag_ofs, frag);
+	  exp.X_op_symbol = debugS_f2_start;
+	  exp.X_add_number = 0;
+	  emit_expr(&exp, sizeof_offset); /* offset in section */
+	  
+	  out_four(e->loc.line | 0x80000000);
+	  
+	  nrlines++;
+
+	  linenum = e->loc.line;
+	}
+	e = e->next;
+      } while(e);
+    }
+    if (debugS_f2_size) {
+      char **mydirs;
+
+      symbol_set_value_now (debugS_f2_size);
+      *symbol_X_add_number(debugS_f2_nrlines) = nrlines;
+      *symbol_X_add_number(debugS_f2_linebytes) = 12 + nrlines * 8;
+      S_SET_VALUE(debugS_f2_codelen, lfrag_ofs);
+      symbol_set_frag(debugS_f2_codelen, lfrag);
+
+      out_four(0xf4);
+      out_header (debugS_seg, &exp); /* section size */
+      debugS_size = exp.X_add_symbol;
+
+      cur_offset = 1;
+      for (i = 1; i < files_in_use; i++) {
+	out_four(cur_offset);	/* filename offset in f3 */
+	if (files[i].dir)
+	  cur_offset += strlen(dirs[files[i].dir]) + 1;
+	cur_offset += strlen(files[i].filename) + 1;
+	out_two(0x0);		/* no checksum */
+	out_two(0x0);		/* pad */
+      }
+
+      symbol_set_value_now (debugS_size);
+
+      mydirs = xmalloc(dirs_in_use * sizeof(char *));
+      for (i = 1; i < dirs_in_use; i++) {
+	char *s1;
+        mydirs[i] = strdup(dirs[i]);
+	while ((s1 = strchr(mydirs[i], '/')))
+	  s1[0] = '\\';
+      }
+
+      out_four(0xf3);
+      out_header (debugS_seg, &exp); /* section size */
+      debugS_size = exp.X_add_symbol;
+
+      out_byte(0x0);		/* filename 0 */
+      for (i = 1; i < files_in_use; i++) {
+	int size;
+	char *cp;
+	if (files[i].dir) {
+	  size = strlen(mydirs[files[i].dir]);
+	  cp = frag_more(size);
+	  memcpy(cp, mydirs[files[i].dir], size);
+	  out_byte('\\');
+	}
+	size = strlen(files[i].filename) + 1;
+	cp = frag_more(size);
+	memcpy(cp, files[i].filename, size);
+      }
+
+      symbol_set_value_now (debugS_size);
+
+      for (i = 1; i < dirs_in_use; i++)
+        free(mydirs[i]);
+      xfree(mydirs);
+    }
+  }
+
+  /* Create and switch to the line number section.  */
+  line_seg = subseg_new (".debug_line", 0);
+  bfd_set_section_flags (stdoutput, line_seg, SEC_READONLY | SEC_DEBUGGING);
+
   out_debug_line (line_seg);
 
   /* If this is assembler generated line info, and there is no
diff -pruN binutils-2.25.1.orig/include/coff/pe_debugS.h binutils-2.25.1/include/coff/pe_debugS.h
--- binutils-2.25.1.orig/include/coff/pe_debugS.h	1969-12-31 19:00:00 -0500
+++ binutils-2.25.1/include/coff/pe_debugS.h	2016-01-14 12:36:28 -0500
@@ -0,0 +1,95 @@
+
+#ifndef _PE_DEBUGS_H
+#define _PE_DEBUGS_H
+
+#if 0
+#define debugS_printf(fmt, a...) printf(fmt, ## a)
+#else
+#define debugS_printf(fmt, a...) do { ; } while(0)
+#endif
+
+typedef unsigned int uint32_t;
+typedef unsigned short uint16_t;
+typedef unsigned char uint8_t;
+
+struct debugS_header {
+  uint32_t dsh_version;
+  uint8_t dsh_data[];
+};
+
+struct debugS_portion {
+  uint32_t dsp_type;
+  uint32_t dsp_len;
+  uint8_t dsp_data[];
+};
+
+struct debugS_linenums {
+  uint32_t dsl_secoffset;
+  uint16_t dsl_secindex;
+  uint16_t dsl_pad1;
+  uint32_t dsl_seccovered;
+  uint32_t dsl_srcoffset;
+  uint32_t dsl_nrpairs;
+  uint32_t dsl_pairslen;
+  struct {
+    uint32_t dslp_offset;
+    uint32_t dslp_lineno;
+  } dsl_pairs[];
+};
+
+struct _debugS_sourcefileinfo {
+  uint32_t dssfi_nameoffset;
+  uint16_t dssfi_checksumtype;
+} ATTRIBUTE_PACKED;
+
+struct debugS_sourcefileinfo {
+  struct _debugS_sourcefileinfo dssfi;
+};
+
+struct debugS_sourcefileinfo_with_cs {
+  struct _debugS_sourcefileinfo dssfi;
+  uint8_t dssfi_checksum[16];
+  uint16_t dssfi_pad1;
+};
+
+struct debugS_sourcefileinfo_without_cs {
+  struct _debugS_sourcefileinfo dssfi;
+  uint16_t dssfi_pad1;
+};
+
+struct debugS_sourcefilename {
+  union {
+    char dssfn_name[0];
+    uint8_t dssfn_data[0];
+  };
+};
+
+struct debugS_info {
+  int di_nr_f2;
+  int di_size_f2;
+  int di_nr_fi;
+  /* struct debugS_sourcefileinfo * */ unsigned char *di_fis;
+  int di_size_fis;
+  int di_nr_fn;
+  /* struct debugS_sourcefilename * */ char *di_fns;
+  int di_size_fns;
+};
+
+struct debugS_outinfo {
+  unsigned int doi_dot;
+  struct bfd_hash_table doi_fnhash;
+  unsigned int doi_fns_space;
+  char *doi_fns;
+  unsigned int doi_fns_dot;
+  unsigned int doi_fis_space;
+  char *doi_fis;
+  unsigned int doi_fis_dot;
+};
+
+struct debugS_fnhash_entry
+{
+  struct bfd_hash_entry root;
+  int fis_offset;
+};
+
+#endif	/* _PE_DEBUGS_H */
diff -pruN binutils-2.25.1.orig/ld/emultempl/pep.em binutils-2.25.1/ld/emultempl/pep.em
--- binutils-2.25.1.orig/ld/emultempl/pep.em	2016-01-14 13:00:17 -0500
+++ binutils-2.25.1/ld/emultempl/pep.em	2016-01-14 13:11:01 -0500
@@ -71,6 +71,7 @@ fragment <<EOF
    header in generic PE code.  */
 #include "coff/x86_64.h"
 #include "coff/pe.h"
+#include "coff/pe_debugS.h"
 
 /* FIXME: These are BFD internal header files, and we should not be
    using it here.  */
@@ -1385,6 +1386,140 @@ setup_build_id (bfd *ibfd)
   return FALSE;
 }
 
+#define process_debugS_fail(fmt, a...) do { printf( fmt, ## a ); return 1; } while(0)
+
+static int
+process_debugS(bfd *abfd, asection *sec)
+{
+  struct debugS_header *dsh;
+  struct debugS_portion *dsp;
+  struct debugS_linenums *dsl;
+  struct debugS_sourcefileinfo *dssfi;
+  struct debugS_sourcefilename *dssfn;
+  struct debugS_info *di;
+  unsigned int i;
+
+  debugS_printf(".debug\$S section in %s, size %ld\n", abfd->filename,
+		sec->size);
+  if (!(sec->flags & SEC_IN_MEMORY)) {
+    sec->contents = xmalloc(sec->size);
+    bfd_get_section_contents (abfd, sec, sec->contents,
+			      (file_ptr) 0, sec->size);
+    sec->flags |= SEC_IN_MEMORY;
+    sec->rawsize = sec->size;
+  }
+  debugS_printf(".debug\$S section in memory at %p\n", sec->contents);
+
+  di = xmalloc(sizeof(*di));
+  memset(di, 0, sizeof(*di));
+  // sec->lineno = (alent *)di;
+  sec->userdata = di;
+  
+  dsh = (struct debugS_header *)sec->contents;
+  debugS_printf(".debug\$S section version %x\n", dsh->dsh_version);
+  if (dsh->dsh_version != 4)
+    process_debugS_fail("version != 4\n");
+
+  dsp = (struct debugS_portion *)dsh->dsh_data;
+  while ((unsigned char *)dsp < sec->contents + sec->size) {
+    debugS_printf(".debug\$S portion at %lx type %x len %x\n",
+                  (unsigned char *)dsp - sec->contents,
+                  dsp->dsp_type, dsp->dsp_len);
+    if (dsp->dsp_data + dsp->dsp_len > sec->contents + sec->size)
+      break; /* process_debugS_fail("portion extends past section\n"); */
+
+    switch (dsp->dsp_type) {
+    case 0xf2:
+      dsl = (struct debugS_linenums *)dsp->dsp_data;
+      debugS_printf("source line number set\n");
+      if (sizeof(*dsl) > dsp->dsp_len)
+	process_debugS_fail("set extends past portion\n");
+      if (sizeof(*dsl) + (dsl->dsl_nrpairs * sizeof(dsl->dsl_pairs[0])) >
+	  dsp->dsp_len)
+	process_debugS_fail("set extends past portion\n");
+      debugS_printf("  start offset 0x%08x section 0x%x\n", dsl->dsl_secoffset,
+		    dsl->dsl_secindex);
+      debugS_printf("  section length covered 0x%x\n", dsl->dsl_seccovered);
+      debugS_printf("  source file info offset 0x%x\n", dsl->dsl_srcoffset);
+      debugS_printf("  #pairs %d (%d bytes)\n", dsl->dsl_nrpairs,
+		    dsl->dsl_pairslen);
+      if (dsl->dsl_pairslen !=
+	  12 + (dsl->dsl_nrpairs * sizeof(dsl->dsl_pairs[0])))
+	process_debugS_fail("pairs number of bytes field incorrect\n");
+      for (i = 0; i < dsl->dsl_nrpairs; i++)
+	debugS_printf("    offset 0x%x line %d%s\n",
+		      dsl->dsl_pairs[i].dslp_offset,
+		      dsl->dsl_pairs[i].dslp_lineno & 0x7fffffff,
+		      dsl->dsl_pairs[i].dslp_lineno & 0x80000000 ? "*" : "");
+      di->di_nr_f2++;
+      di->di_size_f2 += sizeof(*dsl) +
+	(dsl->dsl_nrpairs * sizeof(dsl->dsl_pairs[0]));
+      break;
+    case 0xf4:
+      dssfi = (struct debugS_sourcefileinfo *)dsp->dsp_data;
+      debugS_printf("source file info set\n");
+      if (di->di_fis)
+	process_debugS_fail("duplicate set\n");
+      di->di_fis = (unsigned char *)dssfi;
+      while ((unsigned char *)dssfi < dsp->dsp_data + dsp->dsp_len) {
+	if ((unsigned char *)dssfi + sizeof(*dssfi) >
+	    dsp->dsp_data + dsp->dsp_len)
+	  process_debugS_fail("set extends past portion\n");
+	debugS_printf("  offset 0x%lx: name offset 0x%x checksum %s\n",
+		      (unsigned char *)dssfi - dsp->dsp_data,
+		      dssfi->dssfi.dssfi_nameoffset,
+		      dssfi->dssfi.dssfi_checksumtype == 0x0110 ?
+		      "MD5" : "none");
+	di->di_nr_fi++;
+	dssfi = (struct debugS_sourcefileinfo *)
+	  ((unsigned char *)dssfi +
+	   (dssfi->dssfi.dssfi_checksumtype == 0x0110 ?
+	    sizeof(struct debugS_sourcefileinfo_with_cs) :
+	    sizeof(struct debugS_sourcefileinfo_without_cs)));
+	if ((unsigned char *)dssfi > dsp->dsp_data + dsp->dsp_len)
+	  process_debugS_fail("set extends past portion\n");
+      }
+      di->di_size_fis = dsp->dsp_len;
+      break;
+    case 0xf3:
+      dssfn = (struct debugS_sourcefilename *)dsp->dsp_data;
+      debugS_printf("source file name set\n");
+      if (di->di_fns)
+	process_debugS_fail("duplicate set\n");
+      di->di_fns = (char *)dssfn;
+      while ((unsigned char *)dssfn < dsp->dsp_data + dsp->dsp_len) {
+	int l;
+	if (dssfn->dssfn_data + 1 > dsp->dsp_data + dsp->dsp_len)
+	  process_debugS_fail("set extends past portion\n");
+	for (l = 0; l < dsp->dsp_data + dsp->dsp_len - dssfn->dssfn_data; l++)
+	  if (!dssfn->dssfn_name[l])
+	    break;
+	debugS_printf("  offset 0x%lx: \"%.*s\"\n",
+		      (unsigned char *)dssfn - dsp->dsp_data, l,
+		      dssfn->dssfn_name);
+	di->di_nr_fn++;
+	dssfn = (struct debugS_sourcefilename *)(dssfn->dssfn_data + l + 1);
+      }
+      di->di_size_fns = dsp->dsp_len;
+      break;
+    default:
+      debugS_printf("unknown type %x -- skipping at %lx\n", dsp->dsp_type,
+                    (unsigned char *)dsp - sec->contents);
+      break;
+    }
+
+    dsp = (struct debugS_portion *)(dsp->dsp_data + dsp->dsp_len);
+  }
+  debugS_printf("Summary:\n");
+  debugS_printf("  %d f2 set%s using %d bytes\n", di->di_nr_f2,
+		di->di_nr_f2 != 1 ? "s" : "", di->di_size_f2);
+  debugS_printf("  %d source file info record%s using %d bytes\n",
+		di->di_nr_fi, di->di_nr_fi != 1 ? "s" : "", di->di_size_fis);
+  debugS_printf("  %d source file name record%s using %d bytes\n",
+		di->di_nr_fn, di->di_nr_fn != 1 ? "s" : "", di->di_size_fns);
+  return 0;
+}
+
 static void
 gld_${EMULATION_NAME}_after_open (void)
 {
@@ -1708,11 +1843,217 @@ gld_${EMULATION_NAME}_after_open (void)
 	  }
       }
   }
+  {
+    LANG_FOR_EACH_INPUT_STATEMENT (is)
+    {
+      asection *sec;
+      /* See if this is an import library thunk.  */
+      for (sec = is->the_bfd->sections; sec; sec = sec->next)
+	{
+	  if (strcmp (sec->name, ".debug\$S") == 0)
+	    {
+	      process_debugS(is->the_bfd, sec);
+	    }
+	}
+    }
+  }
+}
+
+static struct bfd_hash_entry *
+debugS_fnhash_newfunc(struct bfd_hash_entry *entry,
+		      struct bfd_hash_table *table,
+		      const char *string)
+{
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (entry == NULL)
+    {
+      entry = (struct bfd_hash_entry *)
+	bfd_hash_allocate (table, sizeof (struct debugS_fnhash_entry));
+      if (entry == NULL)
+	return entry;
+    }
+
+  /* Call the allocation method of the superclass.  */
+  entry = bfd_hash_newfunc (entry, table, string);
+  if (entry != NULL) {
+    struct debugS_fnhash_entry *fe = (struct debugS_fnhash_entry *)entry;
+    fe->fis_offset = -1;
+  }
+
+  return entry;
+}
+
+#define debugS_fnhash_lookup(table, string, create, copy) \
+  ((struct debugS_fnhash_entry *)			  \
+   bfd_hash_lookup((table), (string), (create), (copy)))
+
+#define prepare_debugS_fail(fmt, a...) do { printf( fmt, ## a ); return 1; } while(0)
+
+static int
+prepare_debugS(bfd *abfd, asection *sec)
+{
+  struct debugS_outinfo *doi;
+  struct debugS_info *di;
+  struct debugS_header *dsh;
+  struct debugS_portion *dsp;
+  struct debugS_linenums *dsl;
+  struct debugS_sourcefileinfo *dssfi;
+  struct debugS_sourcefileinfo_without_cs *dssfi_nocs;
+  struct debugS_fnhash_entry *fe;
+  unsigned int fnoffset, i;
+  char *fname;
+  struct bfd_section *out;
+
+  (void)abfd;
+
+  debugS_printf("section from %s output %p size %ld\n", sec->owner->filename,
+                sec->output_section, sec->size);
+
+  di = sec->userdata;
+  if (di == NULL)
+    return 0;
+
+  debugS_printf("debug$S from %s summary:\n", sec->owner->filename);
+  debugS_printf("  %d f2 set%s using %d bytes\n", di->di_nr_f2,
+		di->di_nr_f2 != 1 ? "s" : "", di->di_size_f2);
+  debugS_printf("  %d source file info record%s using %d bytes\n",
+		di->di_nr_fi, di->di_nr_fi != 1 ? "s" : "",
+		di->di_size_fis);
+  debugS_printf("  %d source file name record%s using %d bytes\n",
+		di->di_nr_fn, di->di_nr_fn != 1 ? "s" : "",
+		di->di_size_fns);
+
+  if ((sec->flags & SEC_HAS_CONTENTS) == 0)
+    return 0;
+
+  /* Discard header unconditionally, for when the section has no
+     content but the header. */
+  sec->size -= sizeof(struct debugS_header);
+
+  /* No relocs = no content. */
+  if ((sec->flags & SEC_RELOC) == 0)
+    return 0;
+
+  out = sec->output_section;
+
+  if (out->debugS_outinfo == NULL) {
+    doi = xmalloc(sizeof(*doi));
+    if (doi == NULL)
+      prepare_debugS_fail("alloc debugS_outinfo\n");
+    memset(doi, 0, sizeof(*doi));
+    out->debugS_outinfo = doi;
+    doi->doi_dot = sizeof(struct debugS_header);
+    if (!bfd_hash_table_init(&doi->doi_fnhash, debugS_fnhash_newfunc,
+			     sizeof(struct debugS_fnhash_entry)))
+      prepare_debugS_fail("debugS_outinfo hash init fail\n");
+    doi->doi_fns_space = 1 /* 4096 */;
+    doi->doi_fns = xmalloc(doi->doi_fns_space);
+    doi->doi_fns[0] = 0;
+    doi->doi_fns_dot = 1; /* fn[0] = "\0" */
+    doi->doi_fis_space = 1 /* 128 */;
+    doi->doi_fis = xmalloc(doi->doi_fis_space);
+    doi->doi_fis_dot = 0;
+
+    sec->size += sizeof(struct debugS_header);
+
+    sec->size += 2 * sizeof(struct debugS_portion); /* f3/f4 */
+    sec->size += doi->doi_fns_dot; /* fn[0] */
+  }
+
+  doi = out->debugS_outinfo;
+
+  dsh = (struct debugS_header *)sec->contents;
+  dsp = (struct debugS_portion *)dsh->dsh_data;
+  while ((unsigned char *)dsp < sec->contents + sec->rawsize) {
+    switch (dsp->dsp_type) {
+    case 0xf2:
+      debugS_printf("debugS 0xf2 portion from %s at 0x%x, len 0x%lx\n",
+		    sec->owner->filename, doi->doi_dot,
+		    sizeof(*dsp) + dsp->dsp_len);
+
+      dsl = (struct debugS_linenums *)dsp->dsp_data;
+      dssfi = (struct debugS_sourcefileinfo *)
+	(di->di_fis + dsl->dsl_srcoffset);
+      fnoffset = dssfi->dssfi.dssfi_nameoffset;
+      fname = di->di_fns + fnoffset;
+      for (i = 0; i < dsl->dsl_nrpairs; i++)
+	debugS_printf("    offset 0x%x line %d%s file %s\n",
+		      dsl->dsl_pairs[i].dslp_offset,
+		      dsl->dsl_pairs[i].dslp_lineno & 0x7fffffff,
+		      dsl->dsl_pairs[i].dslp_lineno & 0x80000000 ? "*" : "",
+		      fname);
+
+      fe = debugS_fnhash_lookup(&doi->doi_fnhash, fname, TRUE,
+				FALSE);
+      if (fe->fis_offset == -1) {
+	int l;
+	/* new entry */
+	fe->fis_offset = doi->doi_fis_dot;
+#define FISE_SIZE (sizeof(struct debugS_sourcefileinfo_without_cs))
+	while (doi->doi_fis_dot + FISE_SIZE > doi->doi_fis_space) {
+	  doi->doi_fis_space *= 2;
+	  doi->doi_fis = xrealloc(doi->doi_fis,
+				  doi->doi_fis_space);
+	}
+	dssfi_nocs = (struct debugS_sourcefileinfo_without_cs *)
+	  &doi->doi_fis[doi->doi_fis_dot];
+	dssfi_nocs->dssfi.dssfi_nameoffset = doi->doi_fns_dot;
+	dssfi_nocs->dssfi.dssfi_checksumtype = 0x0;
+	dssfi_nocs->dssfi_pad1 = 0x0;
+	doi->doi_fis_dot += FISE_SIZE;
+	sec->size += FISE_SIZE;
+
+	l = strlen(fname) + 1;
+
+	while (doi->doi_fns_dot + l > doi->doi_fns_space) {
+	  doi->doi_fns_space *= 2;
+	  doi->doi_fns = xrealloc(doi->doi_fns, doi->doi_fns_space);
+	}
+	strcpy(&doi->doi_fns[doi->doi_fns_dot], fname);
+	doi->doi_fns_dot += l;
+	sec->size += l;
+      }
+
+      dsl->dsl_srcoffset = fe->fis_offset;
+
+      break;
+    default:
+      debugS_printf("debugS 0x%x portion from %s at 0x%x, len 0x%lx\n",
+                    dsp->dsp_type, sec->owner->filename, doi->doi_dot,
+		    sizeof(*dsp) + dsp->dsp_len);
+      sec->size -= sizeof(struct debugS_portion); /* f3/f4/unknown */
+      sec->size -= dsp->dsp_len;
+      break;
+    }
+    dsp = (struct debugS_portion *)(dsp->dsp_data + dsp->dsp_len);
+  }
+
+  debugS_printf("sec from %s new size %ld\n", sec->owner->filename, sec->size);
+
+  free(di);
+  sec->userdata = NULL;
+
+  return 0;
 }
 
 static void
 gld_${EMULATION_NAME}_before_allocation (void)
 {
+  {
+    LANG_FOR_EACH_INPUT_STATEMENT (is)
+    {
+      asection *sec;
+      /* See if this is an import library thunk.  */
+      for (sec = is->the_bfd->sections; sec; sec = sec->next)
+	{
+	  if (strcmp (sec->name, ".debug\$S") == 0)
+	    {
+	      prepare_debugS(is->the_bfd, sec);
+	    }
+	}
+    }
+  }
   is_underscoring ();
   before_allocation_default ();
 }
diff -pruN binutils-2.25.1.orig/ld/emultempl/pe.em binutils-2.25.1/ld/emultempl/pe.em
--- binutils-2.25.1.orig/ld/emultempl/pe.em	2016-01-14 13:00:17 -0500
+++ binutils-2.25.1/ld/emultempl/pe.em	2016-01-14 13:11:01 -0500
@@ -71,6 +71,7 @@ fragment <<EOF
    header in generic PE code.  */
 #include "coff/i386.h"
 #include "coff/pe.h"
+#include "coff/pe_debugS.h"
 
 /* FIXME: These are BFD internal header files, and we should not be
    using it here.  */
@@ -1385,6 +1386,140 @@ setup_build_id (bfd *ibfd)
   return FALSE;
 }
 
+#define process_debugS_fail(fmt, a...) do { printf( fmt, ## a ); return 1; } while(0)
+
+static int
+process_debugS(bfd *abfd, asection *sec)
+{
+  struct debugS_header *dsh;
+  struct debugS_portion *dsp;
+  struct debugS_linenums *dsl;
+  struct debugS_sourcefileinfo *dssfi;
+  struct debugS_sourcefilename *dssfn;
+  struct debugS_info *di;
+  unsigned int i;
+
+  debugS_printf(".debug\$S section in %s, size %ld\n", abfd->filename,
+		sec->size);
+  if (!(sec->flags & SEC_IN_MEMORY)) {
+    sec->contents = xmalloc(sec->size);
+    bfd_get_section_contents (abfd, sec, sec->contents,
+			      (file_ptr) 0, sec->size);
+    sec->flags |= SEC_IN_MEMORY;
+    sec->rawsize = sec->size;
+  }
+  debugS_printf(".debug\$S section in memory at %p\n", sec->contents);
+
+  di = xmalloc(sizeof(*di));
+  memset(di, 0, sizeof(*di));
+  // sec->lineno = (alent *)di;
+  sec->userdata = di;
+  
+  dsh = (struct debugS_header *)sec->contents;
+  debugS_printf(".debug\$S section version %x\n", dsh->dsh_version);
+  if (dsh->dsh_version != 4)
+    process_debugS_fail("version != 4\n");
+
+  dsp = (struct debugS_portion *)dsh->dsh_data;
+  while ((unsigned char *)dsp < sec->contents + sec->size) {
+    debugS_printf(".debug\$S portion at %lx type %x len %x\n",
+                  (unsigned char *)dsp - sec->contents,
+                  dsp->dsp_type, dsp->dsp_len);
+    if (dsp->dsp_data + dsp->dsp_len > sec->contents + sec->size)
+      break; /* process_debugS_fail("portion extends past section\n"); */
+
+    switch (dsp->dsp_type) {
+    case 0xf2:
+      dsl = (struct debugS_linenums *)dsp->dsp_data;
+      debugS_printf("source line number set\n");
+      if (sizeof(*dsl) > dsp->dsp_len)
+	process_debugS_fail("set extends past portion\n");
+      if (sizeof(*dsl) + (dsl->dsl_nrpairs * sizeof(dsl->dsl_pairs[0])) >
+	  dsp->dsp_len)
+	process_debugS_fail("set extends past portion\n");
+      debugS_printf("  start offset 0x%08x section 0x%x\n", dsl->dsl_secoffset,
+		    dsl->dsl_secindex);
+      debugS_printf("  section length covered 0x%x\n", dsl->dsl_seccovered);
+      debugS_printf("  source file info offset 0x%x\n", dsl->dsl_srcoffset);
+      debugS_printf("  #pairs %d (%d bytes)\n", dsl->dsl_nrpairs,
+		    dsl->dsl_pairslen);
+      if (dsl->dsl_pairslen !=
+	  12 + (dsl->dsl_nrpairs * sizeof(dsl->dsl_pairs[0])))
+	process_debugS_fail("pairs number of bytes field incorrect\n");
+      for (i = 0; i < dsl->dsl_nrpairs; i++)
+	debugS_printf("    offset 0x%x line %d%s\n",
+		      dsl->dsl_pairs[i].dslp_offset,
+		      dsl->dsl_pairs[i].dslp_lineno & 0x7fffffff,
+		      dsl->dsl_pairs[i].dslp_lineno & 0x80000000 ? "*" : "");
+      di->di_nr_f2++;
+      di->di_size_f2 += sizeof(*dsl) +
+	(dsl->dsl_nrpairs * sizeof(dsl->dsl_pairs[0]));
+      break;
+    case 0xf4:
+      dssfi = (struct debugS_sourcefileinfo *)dsp->dsp_data;
+      debugS_printf("source file info set\n");
+      if (di->di_fis)
+	process_debugS_fail("duplicate set\n");
+      di->di_fis = (unsigned char *)dssfi;
+      while ((unsigned char *)dssfi < dsp->dsp_data + dsp->dsp_len) {
+	if ((unsigned char *)dssfi + sizeof(*dssfi) >
+	    dsp->dsp_data + dsp->dsp_len)
+	  process_debugS_fail("set extends past portion\n");
+	debugS_printf("  offset 0x%lx: name offset 0x%x checksum %s\n",
+		      (unsigned char *)dssfi - dsp->dsp_data,
+		      dssfi->dssfi.dssfi_nameoffset,
+		      dssfi->dssfi.dssfi_checksumtype == 0x0110 ?
+		      "MD5" : "none");
+	di->di_nr_fi++;
+	dssfi = (struct debugS_sourcefileinfo *)
+	  ((unsigned char *)dssfi +
+	   (dssfi->dssfi.dssfi_checksumtype == 0x0110 ?
+	    sizeof(struct debugS_sourcefileinfo_with_cs) :
+	    sizeof(struct debugS_sourcefileinfo_without_cs)));
+	if ((unsigned char *)dssfi > dsp->dsp_data + dsp->dsp_len)
+	  process_debugS_fail("set extends past portion\n");
+      }
+      di->di_size_fis = dsp->dsp_len;
+      break;
+    case 0xf3:
+      dssfn = (struct debugS_sourcefilename *)dsp->dsp_data;
+      debugS_printf("source file name set\n");
+      if (di->di_fns)
+	process_debugS_fail("duplicate set\n");
+      di->di_fns = (char *)dssfn;
+      while ((unsigned char *)dssfn < dsp->dsp_data + dsp->dsp_len) {
+	int l;
+	if (dssfn->dssfn_data + 1 > dsp->dsp_data + dsp->dsp_len)
+	  process_debugS_fail("set extends past portion\n");
+	for (l = 0; l < dsp->dsp_data + dsp->dsp_len - dssfn->dssfn_data; l++)
+	  if (!dssfn->dssfn_name[l])
+	    break;
+	debugS_printf("  offset 0x%lx: \"%.*s\"\n",
+		      (unsigned char *)dssfn - dsp->dsp_data, l,
+		      dssfn->dssfn_name);
+	di->di_nr_fn++;
+	dssfn = (struct debugS_sourcefilename *)(dssfn->dssfn_data + l + 1);
+      }
+      di->di_size_fns = dsp->dsp_len;
+      break;
+    default:
+      debugS_printf("unknown type %x -- skipping at %lx\n", dsp->dsp_type,
+                    (unsigned char *)dsp - sec->contents);
+      break;
+    }
+
+    dsp = (struct debugS_portion *)(dsp->dsp_data + dsp->dsp_len);
+  }
+  debugS_printf("Summary:\n");
+  debugS_printf("  %d f2 set%s using %d bytes\n", di->di_nr_f2,
+		di->di_nr_f2 != 1 ? "s" : "", di->di_size_f2);
+  debugS_printf("  %d source file info record%s using %d bytes\n",
+		di->di_nr_fi, di->di_nr_fi != 1 ? "s" : "", di->di_size_fis);
+  debugS_printf("  %d source file name record%s using %d bytes\n",
+		di->di_nr_fn, di->di_nr_fn != 1 ? "s" : "", di->di_size_fns);
+  return 0;
+}
+
 static void
 gld_${EMULATION_NAME}_after_open (void)
 {
@@ -1708,11 +1843,217 @@ gld_${EMULATION_NAME}_after_open (void)
 	  }
       }
   }
+  {
+    LANG_FOR_EACH_INPUT_STATEMENT (is)
+    {
+      asection *sec;
+      /* See if this is an import library thunk.  */
+      for (sec = is->the_bfd->sections; sec; sec = sec->next)
+	{
+	  if (strcmp (sec->name, ".debug\$S") == 0)
+	    {
+	      process_debugS(is->the_bfd, sec);
+	    }
+	}
+    }
+  }
+}
+
+static struct bfd_hash_entry *
+debugS_fnhash_newfunc(struct bfd_hash_entry *entry,
+		      struct bfd_hash_table *table,
+		      const char *string)
+{
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (entry == NULL)
+    {
+      entry = (struct bfd_hash_entry *)
+	bfd_hash_allocate (table, sizeof (struct debugS_fnhash_entry));
+      if (entry == NULL)
+	return entry;
+    }
+
+  /* Call the allocation method of the superclass.  */
+  entry = bfd_hash_newfunc (entry, table, string);
+  if (entry != NULL) {
+    struct debugS_fnhash_entry *fe = (struct debugS_fnhash_entry *)entry;
+    fe->fis_offset = -1;
+  }
+
+  return entry;
+}
+
+#define debugS_fnhash_lookup(table, string, create, copy) \
+  ((struct debugS_fnhash_entry *)			  \
+   bfd_hash_lookup((table), (string), (create), (copy)))
+
+#define prepare_debugS_fail(fmt, a...) do { printf( fmt, ## a ); return 1; } while(0)
+
+static int
+prepare_debugS(bfd *abfd, asection *sec)
+{
+  struct debugS_outinfo *doi;
+  struct debugS_info *di;
+  struct debugS_header *dsh;
+  struct debugS_portion *dsp;
+  struct debugS_linenums *dsl;
+  struct debugS_sourcefileinfo *dssfi;
+  struct debugS_sourcefileinfo_without_cs *dssfi_nocs;
+  struct debugS_fnhash_entry *fe;
+  unsigned int fnoffset, i;
+  char *fname;
+  struct bfd_section *out;
+
+  (void)abfd;
+
+  debugS_printf("section from %s output %p size %ld\n", sec->owner->filename,
+                sec->output_section, sec->size);
+
+  di = sec->userdata;
+  if (di == NULL)
+    return 0;
+
+  debugS_printf("debug$S from %s summary:\n", sec->owner->filename);
+  debugS_printf("  %d f2 set%s using %d bytes\n", di->di_nr_f2,
+		di->di_nr_f2 != 1 ? "s" : "", di->di_size_f2);
+  debugS_printf("  %d source file info record%s using %d bytes\n",
+		di->di_nr_fi, di->di_nr_fi != 1 ? "s" : "",
+		di->di_size_fis);
+  debugS_printf("  %d source file name record%s using %d bytes\n",
+		di->di_nr_fn, di->di_nr_fn != 1 ? "s" : "",
+		di->di_size_fns);
+
+  if ((sec->flags & SEC_HAS_CONTENTS) == 0)
+    return 0;
+
+  /* Discard header unconditionally, for when the section has no
+     content but the header. */
+  sec->size -= sizeof(struct debugS_header);
+
+  /* No relocs = no content. */
+  if ((sec->flags & SEC_RELOC) == 0)
+    return 0;
+
+  out = sec->output_section;
+
+  if (out->debugS_outinfo == NULL) {
+    doi = xmalloc(sizeof(*doi));
+    if (doi == NULL)
+      prepare_debugS_fail("alloc debugS_outinfo\n");
+    memset(doi, 0, sizeof(*doi));
+    out->debugS_outinfo = doi;
+    doi->doi_dot = sizeof(struct debugS_header);
+    if (!bfd_hash_table_init(&doi->doi_fnhash, debugS_fnhash_newfunc,
+			     sizeof(struct debugS_fnhash_entry)))
+      prepare_debugS_fail("debugS_outinfo hash init fail\n");
+    doi->doi_fns_space = 1 /* 4096 */;
+    doi->doi_fns = xmalloc(doi->doi_fns_space);
+    doi->doi_fns[0] = 0;
+    doi->doi_fns_dot = 1; /* fn[0] = "\0" */
+    doi->doi_fis_space = 1 /* 128 */;
+    doi->doi_fis = xmalloc(doi->doi_fis_space);
+    doi->doi_fis_dot = 0;
+
+    sec->size += sizeof(struct debugS_header);
+
+    sec->size += 2 * sizeof(struct debugS_portion); /* f3/f4 */
+    sec->size += doi->doi_fns_dot; /* fn[0] */
+  }
+
+  doi = out->debugS_outinfo;
+
+  dsh = (struct debugS_header *)sec->contents;
+  dsp = (struct debugS_portion *)dsh->dsh_data;
+  while ((unsigned char *)dsp < sec->contents + sec->rawsize) {
+    switch (dsp->dsp_type) {
+    case 0xf2:
+      debugS_printf("debugS 0xf2 portion from %s at 0x%x, len 0x%lx\n",
+		    sec->owner->filename, doi->doi_dot,
+		    sizeof(*dsp) + dsp->dsp_len);
+
+      dsl = (struct debugS_linenums *)dsp->dsp_data;
+      dssfi = (struct debugS_sourcefileinfo *)
+	(di->di_fis + dsl->dsl_srcoffset);
+      fnoffset = dssfi->dssfi.dssfi_nameoffset;
+      fname = di->di_fns + fnoffset;
+      for (i = 0; i < dsl->dsl_nrpairs; i++)
+	debugS_printf("    offset 0x%x line %d%s file %s\n",
+		      dsl->dsl_pairs[i].dslp_offset,
+		      dsl->dsl_pairs[i].dslp_lineno & 0x7fffffff,
+		      dsl->dsl_pairs[i].dslp_lineno & 0x80000000 ? "*" : "",
+		      fname);
+
+      fe = debugS_fnhash_lookup(&doi->doi_fnhash, fname, TRUE,
+				FALSE);
+      if (fe->fis_offset == -1) {
+	int l;
+	/* new entry */
+	fe->fis_offset = doi->doi_fis_dot;
+#define FISE_SIZE (sizeof(struct debugS_sourcefileinfo_without_cs))
+	while (doi->doi_fis_dot + FISE_SIZE > doi->doi_fis_space) {
+	  doi->doi_fis_space *= 2;
+	  doi->doi_fis = xrealloc(doi->doi_fis,
+				  doi->doi_fis_space);
+	}
+	dssfi_nocs = (struct debugS_sourcefileinfo_without_cs *)
+	  &doi->doi_fis[doi->doi_fis_dot];
+	dssfi_nocs->dssfi.dssfi_nameoffset = doi->doi_fns_dot;
+	dssfi_nocs->dssfi.dssfi_checksumtype = 0x0;
+	dssfi_nocs->dssfi_pad1 = 0x0;
+	doi->doi_fis_dot += FISE_SIZE;
+	sec->size += FISE_SIZE;
+
+	l = strlen(fname) + 1;
+
+	while (doi->doi_fns_dot + l > doi->doi_fns_space) {
+	  doi->doi_fns_space *= 2;
+	  doi->doi_fns = xrealloc(doi->doi_fns, doi->doi_fns_space);
+	}
+	strcpy(&doi->doi_fns[doi->doi_fns_dot], fname);
+	doi->doi_fns_dot += l;
+	sec->size += l;
+      }
+
+      dsl->dsl_srcoffset = fe->fis_offset;
+
+      break;
+    default:
+      debugS_printf("debugS 0x%x portion from %s at 0x%x, len 0x%lx\n",
+                    dsp->dsp_type, sec->owner->filename, doi->doi_dot,
+		    sizeof(*dsp) + dsp->dsp_len);
+      sec->size -= sizeof(struct debugS_portion); /* f3/f4/unknown */
+      sec->size -= dsp->dsp_len;
+      break;
+    }
+    dsp = (struct debugS_portion *)(dsp->dsp_data + dsp->dsp_len);
+  }
+
+  debugS_printf("sec from %s new size %ld\n", sec->owner->filename, sec->size);
+
+  free(di);
+  sec->userdata = NULL;
+
+  return 0;
 }
 
 static void
 gld_${EMULATION_NAME}_before_allocation (void)
 {
+  {
+    LANG_FOR_EACH_INPUT_STATEMENT (is)
+    {
+      asection *sec;
+      /* See if this is an import library thunk.  */
+      for (sec = is->the_bfd->sections; sec; sec = sec->next)
+	{
+	  if (strcmp (sec->name, ".debug\$S") == 0)
+	    {
+	      prepare_debugS(is->the_bfd, sec);
+	    }
+	}
+    }
+  }
 #ifdef TARGET_IS_ppcpe
   /* Here we rummage through the found bfds to collect toc information.  */
   {
